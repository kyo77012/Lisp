2011 spring PL project 1 (OurScheme)

PL OurScheme project for the spring of 2011, Part 1 ("Project 1")

Due : 3/28, 2011 before midnight

  // You are to implement something like the following
                 
  // 'exp' is a pointer that points to a linked list data structure;
  // The linked list data structure results from reading in
  // the user's input.

  Print 'Welcome to OurScheme!'
  Print '\n'
  Print '> '

  repeat
  
    ReadSExp(exp);
    PrintSExp(exp);
    Print '> '
    
  until (OR (user entered '(exit)')
            (END-OF-FILE encountered)
        )

  Print '\n'
  Print 'Thanks for using OurScheme!'

2. Syntax of OurScheme

terminal :
  LEFT-PAREN       // '('
  RIGHT-PAREN      // ')'
  INT              // e.g., '123', '+123', '-123'
  STRING           // "string's (example)." (strings do not extend across lines)
  DOT              // '.'
  FLOAT            // '123.567', '123.', '.567', '+123.4', '-.123'
  NIL              // 'nil' or '#f', but not 'NIL' nor 'nIL'
  T                // 't' or '#t', but not 'T' nor '#T'
  QUOTE            // '
  SYMBOL           // a consecutive sequence of printable characters that are
                   // not numbers, and do not contain '(', ')', single-quote,
                   // double-quote and white-spaces ; 
                   // Symbols are case-sensitive 
                   // (i.e., uppercase and lowercase are different);

Note :

  With the exception of strings, token are separated by the following "separators" :
    (a) one or more white-spaces
    (b) '('                               (note : '(' is a token by itself)
    (c) ')'                               (note : ')' is a token by itself)
    (d) the single-quote character (')    (note : it is a token by itself)
    (e) the double-quote character (")    (note : it starts a STRING)

Examples :

  '3.25' is a FLOAT.
  '3.25a' is a SYMBOL.
  'a.b' is a SYMBOL.
  '#f' is NIL
  '#fa' (alternatively, 'a#f') is a SYMBOL.

Note :

  '.' can mean several things : 
    it is either part of a FLOAT or part of a SYMBOL or a DOT.
    
  It means a DOT only when it "stands alone".
  
  '#' can also mean two things :
    it is either part of NIL (or T) or part of a SYMBOL.
  
  It is part of NIL (or T) only when it is '#t' or '#f' that "stand alone".
  
<S-exp> ::= <ATOM> 
            | LEFT-PAREN <S-exp> { <S-exp> } [ DOT <S-exp> ] RIGHT-PAREN
            | QUOTE <S-exp>
            
<ATOM>  ::= SYMBOL | INT | FLOAT | STRING 
            | NIL | T | LEFT-PAREN RIGHT-PAREN

Once the attempt to read in an S-expression fails, the line 
containing the error-char is ignored.  Start to read in an 
S-expression from the next input line.

Note : a quoted S-expression '... is the same as (quote ...)

   a. In C, the basic program building block is a statement.
      In OurScheme, the basic program building block is 
      an S-expression (S-exp, for short).
      
   b. An S-exp is either an atom, a list, or a dotted pair.
   
   c. An atom is either an integer (e.g., 123), a float
      (e.g., 12.34 or 12. or .34), a string (e.g., "Hi, there!"), 
      or a symbol (e.g., abc).
      
   d. Abc, abc, aBc, a-B!c?, !??, t, nil are examples of symbols
   
      // Blanks and line-returns ("white-space characters") are 
      // considered delimiters
      
      // Upper case and lower case are different, e.g., aB, AB, Ab,
      // ab are all different symbols.
      
      // Each symbol may or may not be bound to an S-exp.
      
      // When I say that a symbol abc is bound to the S-exp
      // (abc "Hi there" (5 3)),
      // you could take what I mean to be that the "value" of abc
      // is (abc "Hi there" (5 3)).
      
      // "Binding" (rather than "value") is a better way of saying 
      // what the situation really is.  
      
      // t, nil are two system-defined symbols 
      //   (t for "true" and nil for "false")
      // They cannot be bound to any S-exp (i.e., they cannot be 
      // treated like user-defined symbols and cannot have values).
      
      // t is also written as #t, meaning "true"
      // nil is also written as () or #f, meaning "false"
      // In other word,
      //   these two are the same : t   #t
      //   these three are the same : nil   #f   ()
      
      // OurScheme understands both 't' and '#t', but it only prints '#t'
      // OurScheme understands all these three : 'nil', '#f', '()',
      //   but it only prints 'nil'.     
      
      // Side remark :
      //   (True) Scheme uses #t, #f and ()
      //   "Other Lisps" use t, nil and ()
      
   e. An ¡uS-exp sequence¡v is of the form
         S1 S2 S3 ... Sn
      where each Si is an S-exp.
      // e.g., (1) 1 (1 . 1)
      // e.g., 1 2 (3 4 (5))
      // Each of the above S-exp sequence contains three S-exp

   f. A dotted pair is of the form
        (SS1 . S2)
      where S2 is an S-exp, whereas SS1 is an ¡uS-exp sequence¡v.
      // Note that there is a dot between SS1 and S2,
      //      with one or more spaces in between
      // e.g., (1 . 2)
      // e.g., (1  2  3  4  . 5)
      // e.g., (1  2  3  4  . ())
      // e.g., (1 . (2 . (3 . abc)))
      // e.g., (1 2 3 . abc)
      // e.g., ((1) (2 (3)) . (abc))
      // e.g., ((1) (2 (3)) . (nil))
      // e.g., ((1) (2 (3)) . nil)
      
   g. The following notations of dotted pairs are equivalent.
      
      (S1 S2 S3 S4 . S5)
      (S1 . (S2 . (S3 . (S4 . S5))))
      
   h. Comment :
      What we refer to as a "dotted pair" is different from what
      other professionals refer to as a "dotted pair".
      
      What other professionals mean by a dotted pair is just
      (S1 . S2), where S1 and S2 are S-exp.
      
   i. A list is of the form
        (SS1)
      where SS1 is an ¡uS-exp sequence¡v.
      // Note : () is known as "the empty list"
      // For historical reasons, () is defined to be the same
      //   as nil or #f, meaning "false"
      
   j. A list (S1 S2 ... Sn) is actually a short-handed
      notation for the following dotted pair
        (S1 . (S2 . (...(Sn . nil)))...)))
      In other words, a list is actually a special kind of
      dotted pair.
      
      Another way of writing the list (S1 S2 ... Sn) is
        (S1 S2 ... Sn . nil)
        
      // In other word, there are three (seven?) ways for writing
      // the same list.
      //   (S1 S2 S3 S4 S5)
      //   (S1 . (S2 . (S3 . (S4 . (S5 . nil)))))
      //   (S1 . (S2 . (S3 . (S4 . (S5 . #f )))))
      //   (S1 . (S2 . (S3 . (S4 . (S5 . () )))))
      //   (S1 S2 S3 S4 S5 . nil)
      //   (S1 S2 S3 S4 S5 . #f)
      //   (S1 S2 S3 S4 S5 . ())
        
   k. When the system prints out a dotted pair, it
      always tries to print it in list-like format.
      
      For example, if the dotted pair is
        (1 . (2 . (3 . (4 . 5))))
      Then the system prints it as
        (1 2 3 4 . 5)
        
      But if the dotted pair is
        (1 . (2 . (3 . (4 . nil))))
      The system does not print it as
        (1 2 3 4 . nil)
      Instead, the system prints it as
        (1 2 3 4)
   
   l. Line comments
   
   A line comment begins with ';' until the end-of-line.
   This ';' must be such that either it is the very first 
   character of the line or there is a separater preceding this ';'
   on this line. 
   
   (Therefore, for example, 'ab;b' is a symbol,
    while 'ab ;b' is the symbol 'ab' followed by a 
    line comment that starts with ';b'.)
        
3. Here are some examples of what your program should
   do for project 1. (The following assumes that your program
   runs interactively.)

Welcome to OurScheme!

> (1 . (2 . (3 . 4)))
( 1
  2
  3
  .
  4
)

> (1 . (2 . (3 . nil)))
( 1
  2
  3
)

> (1 . (2 . (3 . ())))
( 1
  2
  3
)

> (1 . (2 . (3 . #f)))
( 1
  2
  3
)

> a
a

> t
#t

> #t
#t

> nil
nil

> ()
nil

> #f
nil

> (t () . (1 2 3))
( #t
  nil
  1
  2
  3
)

> (t . nil . (1 2 3))
ERROR (unexpected character) : line 1 column 11 character ' '

> ((1 2 3) . (4 . (5 . nil)))
( ( 1
    2
    3
  )
  4
  5
)

> ((1 2 3) . (4 . (5 . ())))
( ( 1
    2
    3
  )
  4
  5
)

> (12.5       . (4 . 5))
( 12.500
  4
  .
  5
)

> (10 12.())   ; same as : ( 10 12. () )
( 10
  12.000
  nil
)

> (10 ().125)   ; same as : ( 10 () .125 )
( 10
  nil
  0.125
)

> ( 1 2.5)
( 1
  2.500
)

> ( 1 2.a)
( 1
  2.a
)

> (1 2.25.5.a)
( 1
  2.25.5.a
)

> (12 (    . 3))
ERROR (unexpected character) : line 1 column 11 character ' '

> "Hi"
"Hi"

> "(1 . 2   . 3)"
"(1 . 2   . 3)"

> (((1 . 2) 
    . ((3 4) 
       . 
       (5 . 6)
      )
   ) 
   . (7 . 8)
  )
( ( ( 1
      .
      2
    )
    ( 3
      4
    )
    5
    .
    6
  )
  7
  .
  8
)

> ())
nil

> ERROR (unexpected character) : line 1 column 1 character ')'

> (Hi there ! How are you ?)
( Hi
  there
  !
  How
  are
  you
  ?
)

> (Hi there! How are you?)
( Hi
  there!
  How
  are
  you?
)

> (Hi! (How about using . (Lisp (instead of . C?))))
( Hi!
  ( How
    about
    using
    Lisp
    ( instead
      of
      .
      C?
    )
  )
)

> (Hi there) (How are you)
( Hi
  there
)

> ( How
  are
  you
)
         
> (Hi
           .
           (there  .(     ; note that there may be no space between
                          ; '.' and '('
           How is it going?))
           )
( Hi
  there
  How
  is
  it
  going?
)

> ; Note : We have just introduced the use of comments.
  ; ';' starts a comment until the end of line.
  ; A comment is something that ReadSExp() should skip when 
  ; reading in an S-expression.
  
(1 2 3) )
( 1
  2
  3
)

> ERROR (unexpected character) : line 1 column 2 character ')'

> (1 2 
   3) (4 5
( 1
  2
  3
)

>       6)
( 4
  5
  6
)

>        '(Hi
           .
           (there  .(     ; note that there may be no space between
                          ; '.' and '('
           How is it going?))
           )
( quote 
  ( Hi
    there
    How
    is
    it
    going?
  )
)

>'(1 2 3) )
( quote
  ( 1
    2
    3
  )
)

> ERROR (unexpected character) : line 1 column 2 character ')'

> '(1 2 3) .25
( quote
  ( 1
    2
    3
  )
)

> 0.250

> (exit  ; as of now, your system only understands 'exit' ;
      )  ; and the program terminates when it sees '(exit)'

Thanks for using OurScheme!

// =================== Q and A No. 1 =======================

Question : '(1 2 3)ªºoutputÀ³¸Ó¬O¤°»ò¡H

Answer :

Project 1 :

> '(1 2 3)
( quote
  ( 1
    2
    3
  )
)


Project 2 :

> '(1 2 3)
( 1
  2
  3
)

¸ÑÄÀ¡G

Project 1¥uÅª¶i¨Ó(«Ø¥XDS)¡B¤£evaluate´Nª½±µ(§âDS)¦L¥X¥h¡A
©Ò¥H±o : (quote (1 2 3))¡C

Project 2¬OÅª¶i¨Ó(«Ø¥XDS)¡Bevaluate(¦¹DS)¡B¦A§âevaluateªºresult
(¨ÌÂÂ¬O­ÓDS)¦L¥X¥h¡A©Ò¥H±o : (1 2 3)¡C

(±N'(quote (1 2 3))'¤©¥Hevaluate©Ò±oªºµ²ªG¬O'(1 2 3)')

// =================== Q and A No. 2 =======================

¡° ¤Þ­z¡m...¡n¤§»Ê¨¥¡G

> ½Ð°Ý¦Ñ¤j~~

> 1.·í¿é¤J'> .'®É¡A·|¬OERROR¶Ü???
>   ­Y¬O¬OERROR.msg¡G·|¬Ocolumn: 1 or 2 ???

   It is an error.  (Let us suppose that it is '> .$', where '$' is
   LINE-ENTER char.)

   column : 2   '.' is the very first user input char
                on this line.  (the space before it is system output)

   Why column 2 and not column 1? Please see my answer to your second

   question below. (The system detects an error when it sees the LINE-

   ENTER char.)

> 2.¦b´ú¸Õ¼Æ¾Ú¤¤¦³¿é¤J(12.5)(12(. 3))

> µª®×¬O:

> > ( 12.500
> )
> > ERROR (unexpected character) : line 1 column 6 character ' '

> ¦ý¬O¦bOurScheme¤¤

> > (12 (    . 3))
> ERROR (unexpected character) : line 1 column 10 character '.'

> ¤§«eªºinput¬O'.'¿ù¡A²{¦bªºinput«h¬O' '¿ù¡A¬°¤°»ò©O???

In the case of (the first one) '(12(. 3))', everything is still

OK when the system (i.e., your system) "sees" '.'.  Why?  Because '.'

may be followed by a digit such as '5'.  The system detects an error

only when it sees that there is a space following '.'.  Therefore, the

"error char" (the char that caused the error) is the space and not the '.'


In the case of (the second one) '(12 (    . 3))', the error char should

also be the space-char following that '.'   You just found an error in my

Project 1 handout.  Thank you.  (And I have taken the liberty to

correct this error in both OurSchemeProj1.txt and HowToWriteOurScheme.doc)


> 3.½Ð°Ýabc"abc·|¦L¥X¤°»ò©O???

  The first token is 'abc'. The second token is a string that starts

  with : "abc

  e.g., // for project 1

  > abc"abc   "
  abc

  > "abc   "

¡÷ yabuki ±À¡G¦Ñ¤j¨ºabc'abcºâ¬Osymbol¶Ü?ÁÙ¬O·|¦³¨ä¥Lµ²ªG?        03/09 22:27
¡÷ hsia ±À¡Gthe case of abc'abc similar to the above case,       03/10 08:57
¡÷ hsia ±À¡Gbecause single-quote, double-quote R separators      03/10 08:58

// =================== Q and A No. 3 =======================

¡° ¤Þ­z¡m...¡n¤§»Ê¨¥¡G

> ³o°ÝÃD§xÂZ«Ü¤[¦Ê«ä¤£±o¨ä¸Ñ¡C

>
> ¨ÌÃD·NÀ³¸Ó¬O³Ì«á¤@­Ó¥i¥H°õ¦æ¡]©Î¦L¥X¡^ªºToken«á±N¦æ¸¹©MÄæ¦ìªì©l¤Æ
> ½d¨Ò¦p¤U

> ()   )
>  ^³oª±·N¨à¬O³Ì«áªºtoken¡A©Ò¥H­n¦L¥X¦bline 1¿ù

> °ÝÃD¨Ó¤F¡G
> "³Ì«á¤@­Ó¦r¦ê"\n
> \n
>   \n
> "¥X¿ùÂI

> ¬°¤°»ò³o¸Ì¦Lline 3¡H§â³Ì«á¤@­Ó¦r¦êtoken®³±¼«áÀ³¸Ó¦p¤U
> \n¡@¡@¡@¡@¡@¡@¡@¡@¡@¡@¡@¡@¡@¡@¢°
> \n                            ¢±
>   \n                          ¢²
> "¥X¿ùÂI                     ²Ä¢³¦æ
> ---------------

> "³Ì«á¤@­Ó¦r¦ê"¡@¡@¡@¡@¡@¡@\n¡@¢°
> \n                            ¢±
>   \n                          ¢²
> "¥X¿ùÂI                       ¢³

> ¥[¤FªÅ¥Õ¬°¤°»ò¤]¬Oline 3¡H

³o¨S¤°»ò¦n¦Ê«ä¤£±o¨ä¸Ñªº¡C ³o¬O³W¹º®Éªº«äºü¤£°÷²Ó±K¡C

ªº½T¡AÄY®æ¨ÓÁ¿¡B«ö·Ó³W©w¡B³Ì«á¤@­ÓcaseªºerrorÀ³¬O²Ä¥|¦æ¡B¦Ó«D²Ä¤T¦æ¡C

·íªì³W¹º®É¥¼¦Ò¼{¨ì¡u¦blegal input¤§«á­YÁÙ¦³(¤]¥u¦³)space«ç»òºâ¤U¤@inputªº¦æ¼Æ¡v

ªº°ÝÃD¡C

¤£¹L¡A§A´N·í³ocase¬O¡ugeneral³W©w¡vªºexception§a¡A·N§Y¡G

  ¦blegal input¤§«á(¦P¤@¦æ)­n¥X²{¡u«Dspace«Dtab¦r¤¸¡v¤~§â³o¤@¦æ
  ºâ§@¬O¤U¤@inputªº²Ä¤@¦æ¡C  ­Ylegal input¤§«á(¦P¤@¦æ)¥u¥X²{
 ¡uspace©Îtab¦r¤¸¡v¡A¨º³o¤@¦æ´N¤£ºâ§@¬O¤U¤@inputªº²Ä¤@¦æ¡C
